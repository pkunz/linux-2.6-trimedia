/*
 * PL031 rtc Driver for ARM Versatile Linux
 *
 *
 * Based on skeleton from the drivers/char/rtc.c driver by P. Gortmaker
 *
 * This code provides the rtc functionality for PL031 hardware
 * present in ARM926EJ-S Versatile 
 *
 * The ioctls can be used to set the interrupt behaviour and
 * generation rate via /dev/pl031rtc.
 *
 * The PL031 hardware does not support the alarm interrupt. Driver does not 
 * have the ioctl implemented for that.
 *
 * The /dev/pl031rtc interface will block on reads until an interrupt
 * has been received.
 *
 * The proc interface can be used to view the register values.
 *
 * The driver is registered as misc driver with minor 137.
 *
 * Please note that we have kept the API as close as possible to the
 * legacy RTC.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * Author:Awanish Kumar Trivedi (awanish.trivedi@wipro.com)
 * Date  :01/02/2006
 *
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/config.h>
#include <asm/io.h>
#include <linux/ioport.h>
#include <linux/wait.h>
#include <linux/miscdevice.h>
#include <linux/spinlock.h>
#include <asm/uaccess.h>
#include <linux/rtc.h>


#include "pl031.h"

static int rtc_freq = 1;

static unsigned int pl031_irq_data;

static struct pl031_rtc data_pl031;

spinlock_t pl031_lock;

static DECLARE_WAIT_QUEUE_HEAD(pl031_wait);
static int pl031_enable_periodic_interrupt(void);
static int pl031_disable_periodic_interrupt(void);
static int pl031_read_register_val(void);

/*
 * Read call for pl031 . The process calling the read call will wait till 
 * the interrupt is received 
 */

static ssize_t pl031_read(struct file *file, char __user *buf, size_t count,
								loff_t *ppos)
{
	DECLARE_WAITQUEUE(wait, current);
	unsigned long data;
	ssize_t retval;
	unsigned long flags;
	add_wait_queue(&pl031_wait, &wait);
	do {
		__set_current_state(TASK_INTERRUPTIBLE);
		spin_lock_irqsave(&pl031_lock, flags);
		data = pl031_irq_data;
		pl031_irq_data = 0; 
		spin_unlock_irqrestore(&pl031_lock, flags);

		if (data != 0) {
			break;
		}
		if (file->f_flags & O_NONBLOCK) {
			retval = -EAGAIN;
			goto out;
		}
		if (signal_pending(current)) {
			retval = -ERESTARTSYS;
			goto out;
		}
		schedule();
	}while (1);

out:
	current->state = TASK_RUNNING;
	remove_wait_queue(&pl031_wait,&wait);
	retval = put_user(data, (unsigned long __user *)buf);
	return 0;
}

/* unmask the interrupt */
static int pl031_enable_periodic_interrupt(void)
{
	unsigned long flags;

	spin_lock_irqsave(&pl031_lock, flags);
	/* read the data register */
	data_pl031.rtcdr = readl(IO_ADDRESS(VERSATILE_RTC_BASE));
	/*set the match register */
	writel(data_pl031.rtcdr+rtc_freq,IO_ADDRESS
		(VERSATILE_RTC_BASE + OFFSET_MATCH_REGISTER));
	/*Unmask the Interrupt */
	writel(PL031_INTERRUPT_UNMASK_BIT,IO_ADDRESS(VERSATILE_RTC_BASE +
			OFFSET_INTERRUPT_MASK_S_R_REGISTER));
	spin_unlock_irqrestore(&pl031_lock, flags);
	return 0;
}

/* mask the interrupt */
static int pl031_disable_periodic_interrupt(void)
{
	unsigned long flags;

	spin_lock_irqsave(&pl031_lock, flags);
	/*mask the Interrupt */
	writel(PL031_INTERRUPT_MASK_BIT,IO_ADDRESS(VERSATILE_RTC_BASE+
			OFFSET_INTERRUPT_MASK_S_R_REGISTER));
	spin_unlock_irqrestore(&pl031_lock, flags);
	return 0;
}

/* handle ioctl calls */
static int pl031_ioctl(struct inode *inode,struct file *file,
			unsigned int cmd,unsigned long arg)
{
	unsigned long flags;

	switch (cmd) {
		case RTC_AIE_OFF:
		case RTC_AIE_ON:
		case RTC_UIE_OFF:
		case RTC_UIE_ON:
		return -EINVAL;

		case RTC_IRQP_READ:
		{
			return put_user(rtc_freq,
				(unsigned long __user *)arg);
		}
		case RTC_IRQP_SET:
		{
			spin_lock_irqsave(&pl031_lock, flags);
			rtc_freq = arg;
			spin_unlock_irqrestore(&pl031_lock, flags);
			return 0;
		}
		case RTC_PIE_ON:
		{
			return pl031_enable_periodic_interrupt();
		}
		case RTC_PIE_OFF:
		{
			return pl031_disable_periodic_interrupt();
		}

	}
	return 0;
}

/* handle the interrupt */
irqreturn_t pl031_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	unsigned long flags;

	data_pl031.rtcrisr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_RAW_INTERRUPT_STATUS_REGISTER));
	/* Check the interrupt status */
	if (data_pl031.rtcrisr == 0)
		return IRQ_NONE;

	/*handle interrupt */
	spin_lock_irqsave(&pl031_lock, flags);
	/* clear the interrupt generated by the hardware */
	writel(PL031_INTERRUPT_CLEAR_BIT,IO_ADDRESS(VERSATILE_RTC_BASE +
				OFFSET_INTERRUPT_CLEAR_REGISTER));
	data_pl031.rtcdr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
					OFFSET_DATA_REGISTER));
	writel(data_pl031.rtcdr+rtc_freq,IO_ADDRESS(
		VERSATILE_RTC_BASE + OFFSET_MATCH_REGISTER));
	pl031_irq_data = 1;
	spin_unlock_irqrestore(&pl031_lock, flags);
	wake_up_interruptible(&pl031_wait);
	return IRQ_HANDLED;
}

static  int pl031_release(struct inode *inode, struct file *file)
{
	return 0;
}

static int pl031_open(struct inode *inode, struct file *file)
{
	return 0;
}

/* structure assignment for file operations */
static struct file_operations pl031_fops = {
	.owner		= THIS_MODULE,
	.read		= pl031_read,
	.ioctl		= pl031_ioctl,
	.open		= pl031_open,
	.release	= pl031_release,
};

/* miscdevice structure assignments */
static struct miscdevice pl031_dev = {
	.minor		= PL031_MINOR,
	.name		= "pl031rtc",
	.fops		= &pl031_fops,
};

/* function to read the register values */
static int pl031_read_register_val(void)
{
	/*data register */
	data_pl031.rtcdr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_DATA_REGISTER));
	/*match register */
	data_pl031.rtcmr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_MATCH_REGISTER));
	/*load register */
	data_pl031.rtclr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_LOAD_REGISTER ));
	/*control register */
	data_pl031.rtccr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_CONTROL_REGISTER));
	/* INT mask reg */
	data_pl031.rtcimsc = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_INTERRUPT_MASK_S_R_REGISTER));
	/* INT raw status */
	data_pl031.rtcrisr = readl(IO_ADDRESS(VERSATILE_RTC_BASE +
		OFFSET_RAW_INTERRUPT_STATUS_REGISTER));
	return 0;
};

static int pl031_proc_show(struct seq_file *seq, void *v)
{
	pl031_read_register_val() ;
	seq_printf(seq,
		"data register\t\t:%ld\n"
		"match register\t\t:%ld\n"
		"load register\t\t:%ld\n"
		"control register\t:%ld\n"
		"interrupt set mask register:%ld\n"
		"raw interrupt status\t:%ld\n",
		data_pl031.rtcdr,data_pl031.rtcmr,
		data_pl031.rtclr,data_pl031.rtccr,
		data_pl031.rtcimsc,data_pl031.rtcrisr);
	return 0;
}

static int pl031_proc_open(struct inode *inode,struct file *file)
{
	return single_open(file, pl031_proc_show, NULL);
}

/* proc fops structure assignment*/
static struct file_operations pl031_proc_fops = {
	.owner		= THIS_MODULE,
	.open		= pl031_proc_open,
	.read		= seq_read,
	.llseek		= seq_lseek,
	.release	= single_release
};

static int __init pl031_init(void)
{
	struct proc_dir_entry *ent;

	/* create a proc Entry */
	ent = create_proc_entry("driver/pl031", 0, NULL);
	if (!ent) {
		printk (KERN_INFO"unable to open proc entry ");
		return -EINVAL;
	}
	else {
		ent->proc_fops = &pl031_proc_fops;
	}

	/* request the irq line */
	if (request_irq(PL031_IRQ, pl031_interrupt, SA_INTERRUPT, "pl031rtc",
						NULL)) {
		printk(KERN_ERR "pl031: cannot register IRQ %d\n",PL031_IRQ);
		return -EIO;
	}

	/*register as a misc driver */
	if (misc_register(&pl031_dev)) {
		free_irq(PL031_IRQ, NULL);
		printk(KERN_ERR "unable to register the driver");
		return -EINVAL;
	}
	/* start the counter any ways */
	writel(PL031_START_COUNT,IO_ADDRESS(VERSATILE_RTC_BASE +
				OFFSET_CONTROL_REGISTER ));
	/* clear the interrupt if its there */
	writel(PL031_INTERRUPT_CLEAR_BIT,IO_ADDRESS(VERSATILE_RTC_BASE +
				OFFSET_INTERRUPT_CLEAR_REGISTER));
	return 0;
}

static void __exit pl031_cleanup(void)
{
	unsigned long flags;

	spin_lock_irqsave(&pl031_lock, flags);
	remove_proc_entry("driver/pl031",NULL);

	/* mask the interrupt generation */
	writel(PL031_INTERRUPT_MASK_BIT,IO_ADDRESS(VERSATILE_RTC_BASE +
				OFFSET_INTERRUPT_MASK_S_R_REGISTER));

	/* free the IRQ line */
	free_irq(PL031_IRQ, NULL);

	/* unregister the misc driver */
	misc_deregister(&pl031_dev);
	spin_unlock_irqrestore(&pl031_lock, flags);
}

module_init(pl031_init);
module_exit(pl031_cleanup);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Awanish Kumar Trivedi");
